---
title: C++重载（Overloading）、重写（Overriding）、重定义（Hiding）的对比与区别
date: 2024-10-08 10:10:29
tags: [C++]
categories: [C++]
---

在C++中，重载、重写和重定义是经常被提到的三种不同的概念，它们都涉及函数的行为和定义，但在语义、作用范围以及使用场景上有明显的区别。理解这三者的差异有助于更好地掌握C++语言的多态性和函数操作。

---

#### 重载（Overloading）

**重载**指的是在同一个作用域（同一个类或函数体内），**函数名相同但参数列表不同**的多个函数共存的现象。重载主要发生在**编译时**，编译器根据参数的类型、个数来区分调用哪个版本的函数。

**特点：**
1. 函数名相同，参数类型或数量不同。
2. 发生在**同一作用域内**。
3. 可以是普通函数的重载，也可以是运算符的重载。

**示例：**

```cpp
class Calculator {
public:
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }
};
```

在这个例子中，`add` 函数被重载了两次，一个处理整数加法，另一个处理浮点数加法。根据传入的参数类型，编译器决定调用哪个函数。

**总结：**
- 发生在编译时。
- 参数列表必须不同。
- 不涉及继承或派生类。

---

#### 重写（Overriding）

**重写**（有时也叫**覆盖**）是在**继承关系**中，派生类重新定义基类中的**虚函数**，以便实现多态性。重写发生在**运行时**，通过基类指针或引用调用的虚函数在运行时根据对象的实际类型决定调用哪个版本的函数。

**特点：**
1. 函数名、参数列表、返回类型必须与基类中被重写的虚函数完全一致。
2. 基类中的函数必须是**虚函数**（用 `virtual` 关键字声明）。
3. 重写主要用于实现**运行时多态**。
4. 使用 `override` 关键字可以显式标记重写的函数（推荐使用）。

**示例：**

```cpp
class Animal {
public:
    virtual void sound() {
        std::cout << "Animal sound" << std::endl;
    }
};

class Dog : public Animal {
public:
    void sound() override {  // 重写基类的虚函数
        std::cout << "Dog barks" << std::endl;
    }
};
```

在这个例子中，基类 `Animal` 的 `sound` 函数是虚函数，在 `Dog` 类中被重写。如果使用 `Animal*` 指向 `Dog` 对象，并调用 `sound` 函数，程序将在运行时调用 `Dog` 的版本。

```cpp
Animal* animal = new Dog();
animal->sound();  // 输出 "Dog barks"
```

**总结：**
- 发生在运行时（动态绑定）。
- 需要继承关系，且基类中的函数必须是虚函数。
- 函数名、参数列表、返回类型必须一致。

---

#### 重定义（Hiding）

**重定义**指的是派生类中的函数与基类中的同名函数没有完全相同的签名（例如参数列表不同），但基类中的函数**并不是虚函数**。在这种情况下，派生类中的函数**隐藏**了基类中的同名函数，即使通过基类指针也无法访问被隐藏的基类函数。

**特点：**
1. 函数名相同，但基类的函数不是虚函数。
2. 可以参数列表不同，但即便相同，仍会隐藏基类的函数。
3. 基类函数被隐藏后，使用基类指针调用时只会访问派生类的版本。
4. 重定义可能会导致意外的行为，因此需要注意。

**示例：**

```cpp
class Parent {
public:
    void print(int x) {
        std::cout << "Parent: " << x << std::endl;
    }
};

class Child : public Parent {
public:
    void print() {
        std::cout << "Child" << std::endl;
    }
};
```

在这个例子中，`Child` 类中的 `print()` 函数隐藏了 `Parent` 类中的 `print(int)`。如果通过 `Child` 对象调用 `print()`，那么只能访问 `Child` 的版本。

```cpp
Child child;
child.print();     // 输出 "Child"
child.print(10);   // 编译报错，Child的print没有参数
```

如果需要调用 `Parent` 中的 `print(int)`，必须显式指定作用域：

```cpp
child.Parent::print(10);  // 输出 "Parent: 10"
```

**总结：**
- 发生在继承关系中。
- 基类中的函数不是虚函数。
- 派生类中的函数与基类同名，但可以有不同的参数列表。
- 派生类函数会隐藏基类函数。

---

#### 三者的对比

| 特性         | 重载（Overloading）    | 重写（Overriding）    | 重定义（Hiding）         |
| ------------ | ---------------------- | --------------------- | ------------------------ |
| 作用域       | 同一类内               | 派生类和基类之间      | 派生类和基类之间         |
| 是否需要继承 | 否                     | 是                    | 是                       |
| 关键字       | 无                     | `virtual`、`override` | 无                       |
| 参数列表     | 必须不同               | 必须相同              | 可以不同                 |
| 返回类型     | 可以不同               | 必须相同              | 可以不同                 |
| 调用时间     | 编译时决定             | 运行时决定            | 编译时决定               |
| 用途         | 提供同名函数的不同版本 | 实现多态性            | 派生类中隐藏基类同名函数 |

---

#### 总结

- **重载**主要用来定义同名函数的多个版本，在编译时根据参数的不同选择合适的函数进行调用。  
- **重写**是为了实现多态性，派生类可以重新定义基类的虚函数，调用时根据实际对象类型决定调用哪个版本的函数。  
- **重定义**则是指派生类中定义了一个与基类同名但不同签名的函数，这会隐藏基类中的版本，导致基类函数不能通过派生类对象直接访问。
