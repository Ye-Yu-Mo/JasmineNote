---
title: C++11特性
date: 2024-05-12 22:32:20
tags:
  - C++
  - C++11
categories:
  - C++
---

# C++11

## 简介

C++11可以说是C语言演变成C++之后第二个重大的标准了，上一个重大的标准是C++98

C++11相较于C++98带来了数量非常非常多的变化，新特性，对C++03进行了很多修正，甚至让C++11变得很不“C++”

但是C++11能更好的用于系统开发和库开发，语法也更进一步泛化，简单化，稳定，安全

这里介绍一些比较实用的语法特性

## 统一的列表初始化

需要注意这里的列表初始化和类的初始化列表不要混淆

### 花括号初始化

在C++98中，我们可以使用花括号对数组和结构体进行统一的初始值的设定

```cpp
struct S
{
    int _a;
    int _b;
};

int main()
{
    int arr[] = {1,2,3};
    int arr[5] = {0};
    S s = {1,2};
    return 0;
}
```

C++11就更像是把花括号括起来的数据作为了一种新的容器，把这种容器再作用于所有的内置类型和自定义类型的初始化，就像使用vector初始化list的感觉差不多，甚至更进一步，他支持省略等于号，也支持new出来的初始化，可以这样写

```cpp
struct S
{
    int _a;
    int _b;
};

int main()
{
    int x1 = 1;
    int x2{2};
    
    int arr1[]{1,2,3};
    int arr[5]{0};
    S s{1,2};
    
    int* pa = new int[4]{0};
    
    return 0;
}
```

学过python的同学是不是感觉优点python那味了

### std::initializer_list

实际上，花括号真的变成了一个容器，叫做initializer_list，也就是初始化列表

官方文档[initializer_list](https://cplusplus.com/reference/initializer_list/initializer_list/)

我们可以通过以下代码查看类型

```cpp
int main()
{
    auto il = {1,2,3};
    cout<<typeid(il).name()<<endl;
    return 0;
}
```

就像我们之前讲的，花括号其实是一种容器，那么他其实就可以用作其他容器的初始化，也可以作为operator=的参数，也就是说，他支持了大括号赋值，那我们就可以写出下面的代码

```cpp
int main()
{
    vector<int> v = {1,2,3,4};
    list<int> lt = {1,2};
    
    map<sting,string> dict = {{"morty","莫蒂"},{"rick","瑞克"}};
    v = {4,5,6};
    return 0;
}
```

## 声明

C++提供了很多简化声明的方式，尤其是在使用模板的情况，如果要全部写出来真的巨麻烦

### auto

这里我们在之前介绍类和对象迭代器的部分也介绍了一点，但是也主要是C++11的介绍，实际上C++98就已经提出了auto但是用法不一样，而且已经舍弃掉了

目前C++11的用法就是可以自动推导类型，但是auto不能作为函数声明的关键字，不能取出目标的类型去声明新的对象

这里就引出了下一个关键字

### decltype

decltype就是可以用于自动推导类型，并且本身可以取出这个类型去声明新的对象

使用方法如下

```cpp
template<class T1, class T2>
void Func(T1 t1, T2 t2)
{
    decltype(t1*t2) ret = t1*t2;
    cout<<"ret的类型是"<<typeid(ret).name()<<endl;
}
int main()
{
    const int x = 114;
    double y = 5.14;
    
    Func(x,y);
    Func(y,'x');
    return 0;
}
```

### nullptr

nullptr其实是从安全和清晰的角度提出的，专门用于表示空指针

因为NULL的本质是字面常量0，他既可以表示指针常量，也就是0x0000000这个地址，也可以表示整形常量0，这样就会导致一些问题了

## 范围for

我们在之前讲迭代器的时候也提出了范围for，一般都是和auto打配合的，也有过比较详细的解释

需要注意的是，这只是我们在写的时候可以比较简化，但本质上还是普通的for循环，只是劳烦编译器进行替换了

## 智能指针

这个一时半会也解释不清楚，我们会在后面出单独的文章进行讨论

## STL的新东西

一个是array容器，这个玩意其实没什么人用，因为一般用C语言形式的数组或者vector都挺香的，提出这个算是弥补一下吧，一般容器有的他都有

第二个是forward_list，这个是实际的单链表，直译是前向链表，list是双链表，我们之前也有做过详细的解释和模拟实现了

第三个是unordered_map和unordered_set，也就是基于哈希实现的无序map和set，我们之前也详细解释和模拟实现

除此之外每个容器都加上了const迭代器，但其实意义不大，因为原本的迭代器其实就足够使用了

接下来就是我们的重头戏了，右值引用和移动语义、可变参数模板、lambda、包装器这些内容会在下一篇文章作为重点来介绍，线程库的相关内容需要在完成Linux部分的介绍之后再进行撰写

## 右值引用和移动语义

### 左值引用和右值引用

所谓的引用就是给变量起别名，那么左值引用和右值引用的区别其实就在于左值和右值

#### 左值与左值引用

左值表示的是一个数据的表达式，比如说变量的名字，或者是解引用的指针，我们可以获取左值的地址，并且可以对左值赋值，左值可以出现在赋值符号的左边，而右值不行

const的左值不能赋值但是可以取地址，左值引用就是给左值取引用，左值引用依然是左值

例如

```cpp
int main()
{
    // 左值
    int a = 1;
    int* pa = &a;
    const int b = 2;
    
    // 左值引用
    int& ra = a;
    int*& rpa = pa;
    const int& b = b;
    int& rpaval = *pa;
    return 0;
}
```

这些用法是我们可以容易理解的

#### 右值与右值引用

右值的本质上也是数据的表达式，但是与左值有不同，例如字面常量，表达式的返回值，函数的返回值（非左值引用返回），右值可以出现在赋值符号的右边，不能取地址

右值引用同样也是对右值取别名，但是取别名之后不能进行赋值等操作（因为赋值的左边只能是左值），并且右值的引用是左值

例如

```cpp
int main()
{
    double x = 11,4, y = 51,4;
    
    // 右值
    5.21;
    x + y;
    add(x,y);
    
    // 右值引用
    int&& rr1 = 1;
    double&& rr2 = x + y;
    double&& rr3 = add(x,y);
    return 0;
}
```

当我们把右值放在赋值符号左边时，就会报C2106错误，赋值符号的左操作数必须是左值

右值不能取地址，但是右值取别名后会背存储到特定的位置，并且可以取到这个位置的地址

也就是说，不能直接对数字11.4取地址，但是对他右值引用rr1，就可以取地址了，甚至可以修改

需要注意的是，左值引用只能引用左值，不能引用右值，但是const左值引用可以引用左值和右值

```cpp
int main()
{
    int a = 0;
    int& ra = a;
    
    const int& rra = 1;
    const int& rrb = a;
    return 0;
}
```

右值引用只能引用右值，不能直接引用左值，但是可以引用move之后的左值

```cpp
int main()
{
    int&& r1 = 1;
    int a = 1;
    int&& r2 = std::move(a);
    return 0;
}
```

### 右值引用有什么用

我们把move之后的左值称之为将亡值，这么叫还是有一些原因的

当初我们在实现vector的时候，进行赋值重载的时候，我们是直接把临时对象中的三个指针和构造出来的三个指针直接进行对换，并没有真正进行拷贝

考虑到这样做的效率确实很高，move的存在也就是为了对变量也能做到这样

如果一个对象存在就是为了去构造别的对象，拿为什么不直接把这个数据直接给他呢

```cpp
string to_string(int val)
{
    string ret;
    // ..
    return ret;
}

int main()
{
    string s1 = to_string(100);
    return 0;
}
```

这里的ret首先会拷贝构造给一个临时对象，然后这个临时对象再拷贝构造给s1

这里的临时对象其实就很多余，这时我们可以写一个右值引用的拷贝构造，因为编译器会调用最合适的那个，他就会调用这个我们写的交换的逻辑，而不是那个逐一拷贝的深拷贝了

```cpp
string(string&& s)
    :_str(nullptr)
    ,_size(0)
    ,_capacity(0)
    {
        swap(s);
    }

```

这种构造我们称之为移动构造，现象叫做移动语义

同样的我们还可以实现移动赋值

需要注意的是，当连续两次进行拷贝构造的时候，如果我们不实现移动构造，他调用的还是深拷贝的那个版本，因此还是移动构造略胜一筹

### 完美转发与万能引用

在函数这里直接写左值或者右值的引用其实只能限制其接收的参数类型，在之后的使用中都会变成左值，为例解决这个问题C++11提出了万能引用，也就是说他既可以接收左值也可以接收右值，并且能保持原来的属性，我们管这个东西也叫做完美转发

```cpp
template<typename T>
void Func(T&& t)
{
   
}
```

## 类的新增功能

### 默认构造

在原有的C++类中，会有6个默认的成员函数，分别是构造函数、析构函数、拷贝构造、赋值重载、取地址重载、const取地址重载

最重要并且经常用的是前四个，后两个用处不大

所谓默认成员函数是当构建一个类的时候，我们不写这些函数，编译器会帮我们生成一个默认的

在C++11中，又新增了移动构造函数和移动赋值重载，这两个我们在上一篇中有详细解释

但是生成的规则会有不同

当你没有显式的写析构、拷贝构造和赋值重载时，编译器会自动生成默认的移动构造和移动赋值重载

默认生成的移动构造函数，对于内置类型会执行按字节拷贝，对于自定义类型，就需要看这个类型是否定义移动构造，有的话就直接调用，没有的话就调用拷贝构造

移动赋值重载和上面的移动构造完全类似

但是当我们自己写了移动构造或者移动赋值，编译器就不会生成拷贝构造和赋值重载了

### 类成员变量初始化

C++11允许在类定义的时候给成员变量缺省值，默认生成的构造函数会使用这些缺省值进行构造，例如

```cpp
class Date
{
private:
	int _year = 1970;
    int _month = 1;
    int _day = 1;
};
```

### 强制生成默认函数的关键字default

这里就是强制生成我们想要的默认函数，我认为这个关键字一是为了方便我们懒得写的时候，并且默认构造函数已经足够使用了，另一方面可以当作一个占位的作用，具体使用形式如下

```cpp
class Date
{
public:
    Date(int year, int month, int day) = default;
private:
	int _year = 1970;
    int _month = 1;
    int _day = 1;
};
```

### 禁止生成默认函数的关键字delete

在C++98中，我们可以将默认函数放在private中就可以实现限制这个函数的生成和使用，在C++11中和default的使用类似

```cpp
class Date
{
public:
    Date(int year, int month, int day) = default;
    Date(Date& _d) = delete;
private:
	int _year = 1970;
    int _month = 1;
    int _day = 1;
};
```

### 继承和多态中的final和override关键字

这里我们在继承和多态中已经讲的非常详细，final可以加在类后面表示该类不能被继承，final和override也可以加在成员函数中，前者表示该函数不能被重写，后者表示必须重写该函数，否则报错

## 可变参数模板

C++11中的可变参数模板是可以接收可变参数的函数模板和类模板

在原先的模板中，我们只能接受一定数量的模板参数，在可变参数模板这里比较抽象，使用也有一定技巧，需要在实践中才能真正理解

这里我们主要简单介绍

一个简单的可变参数模板如下

```cpp
template<class ...Args>
void Func(Args... args)
{}
```

上面的参数args前面有省略号，表示一个可变参数模板，带省略号的参数我们称之为参数包，里面包含了有限多个参数，我们无法直接从参数包args中获取每个参数，只能通过递归的方式来打开这个包，一步步获取

### 递归打开参数包

```cpp
// 递归终止函数
template <class T>
void Func(const T& t)
{
    cout<< t << endl;
}
// 展开函数
template<class T, class ...Args>
void Func(T value, Args... args)
{
    cout << value << endl;
    Func(args...);
}

int main()
{
    Func(1);
    Func(1, "Morty");
    Func(1, "Morty", 2);
    return 0;
}
```

### 逗号表达式打开参数包

这种方式其实并不复杂，主要是利用了初始化列表和逗号表达式来进行展开的过程，其实原理非常简单，看代码就能看懂

```cpp
template<class T>
void Func(T t)
{
    cout<<t<<endl;
}

template<class ...Args>
void func(Args... args)
{
    int arr[] = {(Func(args),0)...}
}

int main()
{
    Func(1);
    Func(1, "Morty");
    Func(1, "Morty", 2);
    return 0;
}
```

### 用途

我们在各个容器的C++11版本接口里面可以看到emplace，支持模板的可变参数，万能引用，那么inset和emplace有什么用呢

emplace支持可变参数，那么在我们需要一次性传入pair变量的时候，就不需要make_pair函数直接构造了，他会自动拿收到的两个参数进行构造

## lambda表达式

当我们在使用仿函数的时候，为了一个简单的功能就要写一个类，这么做还是觉得稍微有点子麻烦

但是诶，他们发现这个lambda还挺好用的，用一句话就能表示出一个简单的函数

例如我们想要表示一个比较大小的函数，或者说是表示升序一个排序仿函数

```cpp
[] (int x, int y) -> bool {return x<y;};
```

诶这么一写，就是一个函数

### 语法

这里的方括号是lambda表达式的标志，用于告诉编译器，接下来这是一个lambda表达式，你要准备好接收了

接下来圆括号里面的是参数列表，箭头指向的就是返回值和函数主体了

一般lambda表达式不要写的太长了，否则可维护性就会变道很差

但是有人要说了，那万一我要用全局的变量呢，之前我们讲过，一对大括号其实就是一个小环境，那么这个小环境里面是不能随便用外面的变量的，因为函数和类本身的设计还是需要高内聚低耦合的

那其实这个方括号里面就可以用来写“全局的变量”，表示，这些变量我要用，别给我禁了

这个方括号里面的内容我们称之为捕捉列表，就好像是从全局中捕获来的变量一样

参数列表和普通的函数列表一样，如果这个函数不需要参数列表，就可以把小括号一起省略

返回值类型在没有返回值的时候可以省略，但其实有返回值的时候也可以省略，编译器会自动进行推导

实际上lambda的本质还是一个类，也就是类似于范围for，写出来是一个样，最后还是还原成他最本来的样子，那么lambda最后还原回去其实就是一个仿函数

那么被捕捉或者定义的变量就是类中的成员变量，但是lambda的一个特性就是，他默认所有的成员变量都是const的，如果想要修改就需要在参数列表之后加上一个mutable

我们甚至可以定义一个变量接收lambda表达式对其进行复用

例如

```cpp
int x = 3;
int y = 5;
auto myswap = [](int& x, int& y)mutable->void
{
    int t = x;
    x = y;
    y = t;
};
myswap(x,y);
```

因为我们其实说了，lambda表达式的本质其实就是一个仿函数，一个类，拿我们也就可以使用typeid.name来读取这个类的名称

实际上他的名称几乎是完全随机不重复的，根据时间，mac地址等内容随机生成

### lambda的捕捉列表

但是有的人又要说了，诶我不一定希望所有的成员变量都可以被改呀，我要是想要使用全部的参数怎么办

基本规则如下

| 语法        | 说明                                           |
| ----------- | ---------------------------------------------- |
| [变量名称]  | 传值某一个变量                                 |
| [=]         | **传值**捕捉父作用域的所有变量，包括类中的this |
| [&变量名称] | 传引用某一个变量                               |
| [&]         | **传引用**捕捉父作用域的所有变量，包括this     |
| [this]      | 捕捉当前的this指针                             |

这些语法可以组合使用，用逗号分割即可，但是不允许重复传递，并且lambda表达式之间**不能**互相赋值，因为我们讲过他们的类名称实际上是不同的，也就是不同的类

## function包装器

出现这个东西的原因主要是因为我们可以调用的东西太多了，而且形式非常相似，函数调用，函数指针调用，仿函数对象，lambda对象都是一模一样的调用方式

那我们可不可以把这些东西全部都放到一起去，包装起来，这样就能使用统一的调用方式来使用上述提到的内容，甚至达到意想不到的效果

例如

```cpp
template<class T1, class T2>
void func1(T1 t1, T2 t2)
{
    cout<<"func1"<<endl;
}

void func2(int x, int y)
{
    cout<<"func2"<<endl;
}

struct func3
{
    void operator()(int x, int y)
    {
        cout<<"func3"<<endl;
    }
};

int main()
{
    auto func4 = [](int x, int y){cout<<"func4"<<endl;};
    return 0;
}
```

这里我们发现其实类型都是没有问题的，但是一旦我们想要使用这些内容，将其作为类似于回调函数的部分来使用，就会出现一些问题

```cpp
template<class Func, class T1, class T2>
void useFunc
{
    Func(T1, T2);
};
```

这里是我们设置的函数，调用如下

```cpp
int main()
{
    useFunc(func1, 1, 2);
    useFunc(func2, 1, 2);
    useFunc(func3, 1, 2);
    useFunc(func4, 1, 2);
    return 0;
}
```

这里其实就会出现一些性能损失，因为在实例化模板的时候就会重复实例化

但是使用包装器就能解决这个问题，例如

```cpp
#include<functional>

int main()
{
    function<void(int,int)> Func1 = func1(); 
    function<void(int,int)> Func2 = func2; 
    function<void(int,int)> Func3 = func3; 
    function<void(int,int)> Func4 = [](int x, int y){cout<<"func4"<<endl;};
    useFunc(Func1, 1, 2);
    return 0;
}
```

这样子我们在传入回调时，其实就只会实例化一份function对象的类型了

回调函数使用比较多的场景主要还是命令行之类的解释器，还有之后我们实现的线程池，创建线程的时候会用到

目前只需要了解大致的原理即可，function的本质还是一个类
