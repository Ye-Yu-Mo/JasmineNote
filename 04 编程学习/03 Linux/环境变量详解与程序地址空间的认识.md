---
title: Linux进程——环境变量之二
date: 2024-07-25 20:24:46
tags: [Linux,进程]
categories: [Linux]
---

## 环境变量

### 查看环境变量

在上一篇文章中我们只说了查看某个环境变量的值，那么如何查看所有的环境变量呢

使用指令`env`即可

例如

![QQ_1721910604069.png](https://s2.loli.net/2024/07/25/TQs5VtrCFxjEinm.png)

这里我们也不需要全部记住，只需要记住一些比较常见的

1. PWD
   这个环境变量就是给pwd指令的结果了
2. HOME
   这里对应的就是cd ~命令了，找到家在哪里

那其实在我们登录Xshell时，他所做的工作就是认证信息，将bash加载到内存，形成进程，根据用户名初始化环境变量，进入家目录

这样我们其实就能理解为什么当我们直接改环境变量值的之后，直接重启Xshell就能恢复了，因为每一次都要重新加载初始化

### 获取环境变量

那么在C语言中是如何获取环境变量呢

就是使用`getenv()`函数即可，返回值即为环境变量的值，参数是环境变量名称

例如

```c
char* ret = NULL;
ret = getenv("PATH");
```

### main()的第三个参数

我们之前说了main的前两个参数，表示命令行参数表

```c
int main(int argc, char* argv[], char* env[])
```

这里的第三个参数其实就是环境变量的指针数组，他指向的就是环境变量表

我们可以像之前一样循环打印看看环境变量

```c
#include<stdio.h>
int main(int argc, char* argv[], char* env[])
{
    for(int i=0; env[i]!=NULL; i++)
    {
        printf("%d : %s\n", i, env[i]);
    }
    return 0;
}
```

### 本地变量

我们可以在bash中直接定义环境变量，直接使用等号即可

`环境变量=值`

然后使用`echo $环境变量`就能查看了

但是我们自己定义的变量本质上是本地的，使用env是查不到的

但如果我们想要定义的环境变量被放在系统中的变量中，就需要`export 环境变量名`

### 全局环境变量

在上面的一系列介绍中，我们很容易产生一种感觉，分为临时的本地变量和全局的环境变量，事实上也就是如此

在修改或者定义环境变量时，我们只修改了bash进程中的环境变量，当我们重新登录之后，bash又恢复成原来的样子了

这时因为bash解释器会从`bash_profile`文件中初始化环境变量

也就是说，如果我们想要彻底将一个环境变量保存，就需要保存到他的配置文件当中

![QQ_1721912108865.png](https://s2.loli.net/2024/07/25/LG48nOC9XNSwkMb.png)

并且我们联系之前的知识，由父进程创建的进程会采用写时拷贝的方式来达到共用的目的，也就是说父进程的环境变量可以被子进程使用

这也就是说环境变量具有全局性

在c语言中其实也算是这样，我们可以使用`extern`来声明外部环境变量

### 内建命令与常规命令

我们知道bash的命令不用加上路径是因为他存在环境变量PATH里了

但如果我们将PATH置空，这些命令自然也就不能运行了，但是有一些指令，比如说pwd、echo，仍然可以正常运行

这主要是因为Linux的指令分为两类，一类是bash创建子进程执行的，称之为常规命令，另一类是bash自己执行的，相当于调用一个函数，称之为内建命令

