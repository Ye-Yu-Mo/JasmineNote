---
title: Linux进程——进程的概念
date: 2024-07-12 16:07:53
tags: [Linux,进程]
categories: [Linux]
---

我们在上一节内容中有简单谈到进程的感性理解，他在课本上的概念是，程序的一个执行实例或正在执行的程序

但在本质上，他其实就是一个被分配了系统资源（CPU，内存）的实体

## PCB

上一节内容中，我们说到，管理是管理的数据，需要先描述再组织

那在内存中，操作系统对多个进程应当如何管理呢

这时候就有聪明的同学回答了，先描述再组织

我们还是使用结构体来进行描述，对于一个进程来说可能会有进程ID、代码存储地址、进程状态、进程优先级，如果是用链表的形式存储还会有指向下一个结构体的指针

```cpp
struct data
{
	// id
    // 代码地址
    // 状态
    // 优先级
    struct data* next;
};
```



那么这样一个结构体，我们给她起一个名字，叫做PCB，进程控制块

当然在不同的操作系统中，管理所用的PCB名称也不一定相同，在Linux中，这个PCB具体叫做`struct task_struct`，进程控制块

那么操作系统对进程的管理就变成了对链表的增删查改

## 进程排队

当进程在链表中，就会等待CPU去找PCB来进行处理，那么CPU是如何知道要处理哪些数据的

因为CPU不可能同时处理非常多的进程，就需要让这些进程排队，我们称之为进程队列，也使用指针进行链接

那么在内存中，一个PCB进程控制块就有可能同时处于多个链表（队列）

## 进程标识符pid

我们要区分不同的进程，就得使用唯一标识符，pid

我们可以使用`ps ajx`命令来查看

![QQ_1720772801665.png](https://s2.loli.net/2024/07/12/2lChnHyAVMgPcm8.png)

当然这样是查看所有的进程，我们可以使用grep命令来进行筛选

这里先简单写一个死循环程序让他一直运行

![QQ_1720773063499.png](https://s2.loli.net/2024/07/12/7WQTfwqhGYmC4bS.png)

运行起来是这样的

![image.png](https://s2.loli.net/2024/07/12/LpYlcUJg4tGBXVK.png)

![image.png](https://s2.loli.net/2024/07/12/8Gp2tnh1exCVgqk.png)

使用head -1是为了打出来表头，这里出来两个，第一个是本身的进程，第二个是grep命令的进程

## 终止进程

我们比较常用的终止进程的方法是`ctrl+c`来结束进程，但是这种方法只能在运行程序的地方，并且只能在前台来结束当前进程，对于后台程序我们是没办法让他结束的

第二个方法是一个指令`kill -9 pid`我们将pid直接替换为进程id即可

例如上面的进程可以直接使用`kill -9 20990`就能杀掉这个进程了

-9表示信号参数，我们这里先直接使用

## 获取进程id

当我们在程序中想要自动获取进程的id的时候，就不能使用ps命令了，在c语言中有一个函数是`getpid`，可以获取本进程的pid，下面是使用的示例

```cpp
#include<iostream>
#include<unistd.h>
#include<sys/types.h>
using namepsace std;
int main()
{
    pid_t id = getpid();
    while(1)
    {
        cout<<"我是一个进程"<<endl;
        cout<<"我的pid是："<<id<<endl;
        sleep(1);
    }
    return 0;
}
```

![QQ_1720773984208.png](https://s2.loli.net/2024/07/12/rtluKfOq1F26p4n.png)

## 父进程与子进程

我们在上面使用ps命令查看进程id的时候，坐标还有一个ppid，着就表示父进程，我们也可以使用getppid来查看父进程id

但其实我们每一次运行这个程序的时候，子进程的id可能会不同，但父进程的id都相同

一般情况下，在命令行中，父进程其实就是命令行解释器`bash`

那么关于如何创建子进程，为什么只有父进程id，本进程id，看不到子进程id呢，我们将在下一篇文章中继续学习
