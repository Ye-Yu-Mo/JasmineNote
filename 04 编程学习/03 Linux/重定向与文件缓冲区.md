---
title: Linux基础IO——重定向与文件缓冲区
date: 2024-08-07 18:53:18
tags: [Linux,进程]
categories: [Linux]
---

## 重定向

我们在学习Linux的基本内容时候，知道`>> >`都可以用来表示重定向，那么重定向的本质是什么呢，其实就是更改了标号为1的文件描述符

1表示标准输出，那么我们也就可以手动实现输出重定向，将标准输出更改为我们指定的文件

```c
  1 #include<unistd.h>
  2 #include<sys/types.h>
  3 #include<sys/stat.h>
  4 #include<fcntl.h>
  5 #include<stdio.h>
  6 
  7 int main()
  8 {
  9   close(1);
 10   int fd = open("log.txt",O_WRONLY|O_CREAT|O_TRUNC,0666);
 11   printf("关闭1之后新建文件标识符为%d\n",fd);
 12   fprintf(stdout,"输出到更改后的标准输出\n");               
 13   return 0;
 14 }
```



![image.png](https://s2.loli.net/2024/08/07/t5gqh89Cbs3NlYy.png)

那么重定向的本质是什么，他究竟做了什么操作呢

其实就是跟我们前一节内容所讲的一样，通过修改文件描述符表，修改文件描述符到指定文件的指针即可，也就是修改文件描述符下标为1的数组内容，改成到你想要的文件即可

### 重定向的系统调用

如果每一次我们想要重定向都需要写上面那些个代码，先关闭再打开，这样一点都不优雅

操作系统也是这样想的，于是就有了dup和dup2这两个系统调用

![image.png](https://s2.loli.net/2024/08/07/Mi9B4EabjHf1FCU.png)

其实就是传递给他文件描述符，dup是直接关了，dup2是讲oldfd拷贝给newfd，这样你原本想输出给oldfd的内容就输出给了newfd

### C语言中的FILE结构体

因为程序语言的所有操作其实都是通过操作系统提供的系统调用来完成的

我们就可以推断出，C语言提供的所有IO相关函数都与系统调用的接口对应，从本质上，所有访问文件的操作都是通过文件描述符fd来访问的

因此在C语言的FILE结构体中，也一定存着文件描述符fd

## 文件缓冲区

IO设备的读写速度是远低于内存和CPU的运转速度的，这其实就说明了缓冲区的重要性，不要让CPU和内存频繁访问IO设备，多和文件缓冲区打交道，当满足条件的时候，一起传递给外设即可

### C语言缓冲区

我们说当满足一定条件就传递信息，这个一定条件具体指的是什么呢

缓冲区其实就可以理解为操作系统提供的一段内存，一般有三种条件

* 当缓冲区收到信息时立即传递——立即刷新
* 当缓冲区存到了一定量（cache）时传递——行刷新
* 当缓冲区存满了时传递——满刷新

当然还有一些其他情况，比如说进程关闭时刷新，调用系统调用时刷新

一般操作系统里面都是看情况用的，例如显示器就选择行刷新，因为要注重用户体验，访问磁盘时则是满刷新，效率更重要一点

因此当标准输出重定向到普通文件时，行刷新就变成了满刷新

还有我们之前提到的'\n'会自动刷新缓冲区，如果有竞赛经验的同学也知道可以关闭自动缓冲区刷新来节省时间，fflush函数可以强制刷新缓冲区

