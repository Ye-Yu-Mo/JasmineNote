---
title: Linux进程控制——进程终止
date: 2024-07-27 17:17:32
tags: [Linux,进程]
categories: [Linux]
---

## 进程终止

我们之前在命令行界面要终止一个进程时直接`ctrl+c`来干掉一个进程是比较暴力的做法

实际上我们通常会使用一些函数调用接口或者系统调用接口来控制进程的退出

就像我们完成一个任务一样，有完成和未完成两种结果，完成也可以分为完美完成和不完美完成

对应下来就是三种结果，代码执行完成、结果正确；代码执行完成、结果不正确；代码异常终止

前两个都属于是程序正常退出，一般有三种常见的方法，main函数return返回、调用exit终止进程、调用_exit终止进程

而第三种则是异常退出，一般情况下异常往往是与信号相关的内容，我们之后再做介绍，这里我们只考虑`ctrl+c`终止进程

### 从main函数return返回

在一开始学习C/C++时，在main函数结尾都会写一个return 0，当时的解释就是表示程序正常结束

那么也就说明有异常结束的情况了，首先要说明的一些情况是这样的

一个进程中只有一个main函数，也有的书中将函数称之为子程序，这是因为函数也可以return值，那么其实就可以说明，非main函数return时，表示这个函数完毕，而main函数执行到return时，说明这个进程执行完毕

程序正常执行完毕且结果正确，返回0

程序正常执行完毕但结果不正确，返回非0

但是非0的情况那么多，他们分别代表什么呢

这里就有一个函数，`strerror`，他可以将错误码转换成对应的字符串信息，这样我们就可以打印来查看了

![image.png](https://s2.loli.net/2024/07/27/Pcpt2y9J1fbnrFR.png)

```c
#include<stdio.h>
#include<string.h>
int main()
{
        int i=0;
        for(i=0; i<200; i++)
        {
                printf("%d: %s\n", i, strerror(i));
        }
        return 0;
}
```



![image.png](https://s2.loli.net/2024/07/27/emyK5oXwYjhB9qE.png)

虽然我们循环写到了200，但是他这个错误类型只有133个，之后就显示未知错误

我们也可以使用`echo $?`来查看退出码

例如

![image.png](https://s2.loli.net/2024/07/27/LBu62MOX4PZDQjC.png)

这里可以看到是完全对应的

### exit退出

![image.png](https://s2.loli.net/2024/07/27/lyj92Jo1BzidcQg.png)

函数调用的参数其实就是上面的错误码，和main函数中的return是一个意思

但是也有不同的地方，return只有在main函数中才表示进程退出，而exit在程序的任何地方都表示进程退出并且返回错误码，之后的内容也就不会继续执行了

### _exit和exit的区别

_exit的头文件是`unistd.h`，和exit都是终止进程，并且他的参数也是表示错误码

这两个函数有什么区别，我们可以写一个代码来看看

![image.png](https://s2.loli.net/2024/07/27/C4LOEBpd1A6VSDW.png)

第一个退出打印了文字，而第二个没有

我们需要联系以前所学的知识，因为使用printf打印数据如果不用回车换行的话，数据就会被存到缓冲区了，而exit打印了就说明exit帮我们刷新了缓冲区的内容，而_exit并没有

exit是c语言提供的库函数，_exit是由操作系统提供的系统调用，就说明了，缓冲区其实不是由操作系统来维护的，而是由实现他的c语言标准来维护的

### 程序异常终止

异常终止的情况主要是由信号来控制的，此时我们再讨论程序的退出码其实就没有意义了，因为程序根本就没有正常执行下去，例如数组越界，`ctrl+c`干掉程序都是一样的

### perror与errno

我们之前在学习C/C++的时候，有用过一个全局变量是errno

这里面存的是最近的一个错误码，例如当fopen函数打开文件失败，errno就会被赋值

perror和errno经常搭配使用，他会输出errno错误码对应的错误信息，并且perror的参数代表的是那个地方有问题，这是由用户来决定的

例如

```c
FILE& fp = fopen("text.txt","r");
if(fp==NULL)
{
    perror("fopen");
    exit(1);
}
```



