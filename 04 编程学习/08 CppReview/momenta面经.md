自我介绍：

老师您好 我叫许磊 是来自安徽大学数据科学与大数据技术专业的一名大三学生 虽然是大数据相关专业的 但是我在学习的过程中发现自己对软件开发非常感兴趣

通过各自渠道自学和蹭课的方式系统的学习了C++ 并且将学习的经验和知识总结成博客 目前已经有了15w以上的访问量

除此之外我还将自己所学的知识进行应用，目前已经完成了两个简单的小项目，分别是仿照RabbitMQ的消息队列的实现，还有一个简单易用的日志系统

对于咱们公司我也有很大的兴趣，希望此次面试让我们双方有一个更加深入的了解

项目介绍：

第一个项目是关于消息队列的，主要使用的技术栈是C++14 Protobuf作为序列化和反序列化框架 muduo库用来封装TCP长连接的 使用SQLite3提供持久化信息处理能力 可以从数据库中加载交换机 消息队列中的信息 使用Gtest来测试每个单元的功能 还有一些拓展功能正在做 例如用户管理和网页管理

第二个项目是关于日志系统的，基本功能是没有用到其他的框架的，在做完基本功能之后我是使用json作为简单的序列化和反序列化框架 然后自己封装了一下TCP的socket 实现了远程落地到服务器的功能 然后可以使用SQLite来存储到数据库中 目前正在做基于日志数据库的数据分析功能

项目问答：

1. 路由功能是怎么实现的 原理是什么

   > 路由关键字是分为routing key和binding key，binding key是和各个队列关联的 类似于RabbitMQ采用从前向后匹配的策略 具体的匹配算法是使用动态规划对 routing key进行匹配 找到对应的消息队列 

2. 你是怎么提高并发处理用户请求的

   > 是使用线程池进行处理用户发布消息请求的

3. 服务端处理用户请求的时候，是阻塞还是非阻塞？为什么

   > 是采用阻塞的 当多线程并发处理用户请求时 如果采用非阻塞可能会导致一个资源还没有初始化完成就直接使用 从而出现问题

4. 线程池你是怎么实现的

   > 是实现了一个简单的版本 主要是有任务池和线程池 用户可以把任务push到任务池中 采用了模板参数包进行任务函数传参和使用decltype自动推导返回值类型和std::future返回任务函数的返回值 线程会自动取出任务进行执行

知识问答：

1. 熟悉c吗，讲一下你对c和c++的理解

   > C语言是面向过程的 主要特点就是效率高 非常简洁 对内存的控制非常直接
   >
   > C++是面向对象的 在现代C++中有了模板 智能指针等非常多的特性 让C++与C语言有了质的区别 除此之外C++还有STL标准模板库 可以方便的使用很多容器

2. 讲一下stl库

   > STL库主要分为几个部分 分别是容器 算法 迭代器 函数对象 适配器等内容 其中比较核心的就是容器 迭代器 和算法

3. 讲一下static关键字

   > static可以大致分为几种用法
   >
   > * 静态变量
   >   * 局部 只初始化一次 之后调用时保留上一次的值
   >   * 全局 只能用于当前文件
   > * 静态函数
   >   * 表示改函数的作用域仅用于当前文件
   > * 静态成员
   >   * 表示所有类公有的成员 属于类本身 不属于某个具体的实例
   >   * 通过类名访问 不需要创建类的对象
   >   * 静态成员变量是在类内声明 必须要在类外定义

4. C++标准库的多线程函数\类有哪些

   > thread类 用于创建和管理线程 通过传递可调用对象来启动新线程
   >
   > mutex类 互斥锁 用来保护共享数据
   >
   > 条件变量 用来维护线程间的同步关系
   >
   > atomic类 原子变量

5. 可调用对象有哪些类型，了解过包装器，bind吗

   > 可调用对象有 函数 函数指针 仿函数 lambda表达式 
   >
   > bind函数是用于固定原来可调用对象的某些参数 返回一个新的可调用对象

6. 各类智能指针的简单实现 区别是什么

   > unique_ptr是独占指向资源的所有权的 只能指向一个对象 不能被复制 只能移动
   >
   > shared_ptr是可以指向同一个对象的 通过引用计数来管理对象的所有权
   >
   > weak_ptr是用来辅助shared_ptr的 用来打破shared_ptr的循环引用 不会增加引用计数 不控制对象的生命周期 不能用来直接访问对象

7. 智能指针为什么避免传入裸指针

   > 有可能会导致内存重复释放或者内存泄漏

8. 各种设计模式的特点和写法

   > 单例模式：一个类只有一个实例 提供一个全局访问点 有饿汉模式和懒汉模式 饿汉模式在类加载时就会创建实例 通过静态成员变量来控制实例的创建 懒汉模式是在第一次使用时才会创建实例 适用于实例化时间比较长的时候
   >
   > 工厂模式：定义一个接口用于创建对象，让子类工厂来生产具体的子类
   >
   > 建造者模式：将一个复杂的对象构建过程进行分离 最后使用一个建造结构统筹构建整体

9. 你知道哪些锁 锁的底层原理

   > 互斥锁：最基本的锁 同一时刻只有一个线程能够访问共享资源 通过一个标志位来表示锁的状态
   >
   > 读写锁：允许同时读取共享线程 但是不允许同时写 适用于读多写少的场景 内部维护了一个读的计数器和一个写的互斥锁 还会需要确保写优先
   >
   > 递归锁：允许一个线程多次获得一把锁 不会导致死锁 递归锁内部维护的是一个计数器和线程标识符

10. lambda表达式详细讲一讲 常用的捕获列表有什么 引用捕获和传值捕获有什么区别 怎么捕获类的成员变量

    > lambda表达式是一种匿名函数对象 本质上是通过仿函数来实现的
    >
    > 可以通过值捕获 引用捕获，还可以用=值捕获所有变量 &引用捕获所有外部变量
    >
    > 引用捕获和传值捕获类似于函数的传值和传引用 传值会重新构造一个一模一样的对象 传引用则直接可以操作传递的对象本体
    >
    > 如果要捕获成员变量可以直接捕获this，就可以在lambda内部直接访问成员变量了

11. 你还了解哪些C++11的特性

    > auto自动推导类型 范围for 右值引用 初始化列表

12. 模版类的实现为什么一般都放在在头文件中，不像其它函数实现放在库文件或者源文件中

    > 模板的特性是需要在编译时就需要实例化出不同类型的函数 如果在不同的文件中可能会让链接器找不到对应的函数 放在同一个文件中维护性和易用性都会好一些

13. 什么是左值，什么是右值？std::move？

    > 左值是在赋值号左边的表达式 是一个持久的对象 通常可以是局部变量 全局变量 成员等 有确定的位置和生命周期 可以被单引用符号取引用 变为左值引用
    >
    > 右值就是赋值号右边的表达式 通常是临时对象或者字面值 也称之为将亡值 没有持久的存储地址 主要用途是用于计算表达式的结果 可以用来减少拷贝的次数
    >
    > std::move可以将一个对象转换为右值引用 可以调用移动构造函数和移动赋值

14. C++如何实现识别一个引用是左值还是右值？

    > 可以用is_lvalue_reference模板函数来判断是否是左值 同样的也可以判断右值

15. 完美转发与万能引用，底层原理了解过吗？

    > 完美转发是将模板函数的参数保持原来的特性传递到其他函数中std::forward
    >
    > 万能引用就是使用模板T&& 可以接收左值引用也可以接收右值引用
    >
    > 底层原理是使用引用折叠：只要有一个是单引用符号就折叠为单引用符号 也就是左值引用 两个都是双引用符号就折叠为右值引用了

16. 类内声明变量的缺省值与构造函数内赋值的区别？

    > 类内声明可以使用所有的构造函数 提高可读性 可以被构造函数赋值给覆盖
    >
    > 构造函数可以从外部获取初始化的值 用来赋值给类内变量

17. 初始化列表的意义？

    > 是一种辅助的容器 可以方便的使用大括号将变量括起来 用来初始化或者存储其他的对象都挺好用的

18. 指针的类型转换问题？

    > 指针类型转换分为隐式转换和显示转换
    >
    > 隐式转换是编译器自动进行转换的，可以将父类指针转换为子类指针 是安全的
    >
    > 显示转换是可以来调用的
    >
    > static_cast 是安全的基本类型之间的转换
    >
    > dynamic_cast 是运行时的向下类型转换 出错抛异常 要求转换的类必须有虚函数
    >
    > const_cast 用于去除const属性
    >
    > reinterpret_cast 不考虑安全情况的转换 不太了解

19. C++里面的多态是怎样实现的？父类的指针去调用到子类对象的虚函数，是怎样做到的？除了用虚函数实现多态，在C++里面还有没有其他的方式实现多态？

    > 多态是分为静态多态和动态多态 函数重载和模板函数都属于静态多态 虚函数加上重写是属于动态多态
    >
    > 父类指针调用子类函数主要是通过运行时类型决定调用对应的函数 也就是动态绑定

20. 为什么有的析构必须声明成虚函数？

    > 这里主要是在多态中会考虑到的 父类和子类都是destruct析构函数 这两个是构成重写的 如果父类析构函数不是虚函数的话 使用父类指针指向子类时 父类调用析构函数 子类的析构函数就不会被调用 从而产生资源泄露的问题

21. 实现一个类 不允许被拷贝\只能在堆上创建对象\只能在栈上创建对象\不允许被继承

    > 不允许被拷贝：把拷贝构造和赋值重载定义为private
    >
    > 只允许在堆上创建：禁止构造函数和拷贝构造函数 提供一个静态成员函数 通过new来返回堆上创建的对象
    >
    > 只允许栈上创建：禁用new和delete 构造函数和拷贝构造 提供一个静态函数 通过栈上创建
    >
    > 不允许被继承：构造函数私有 子类无法调用父类的构造函数 通过静态方法获取对象

22. vector list map的关系和实现 三者对应的数据结构模型是什么 你是怎么用list接口判断list的底层是带头双向循环链表的

    > vector 对应的是数组 list对应的是双向链表 map对应的是二叉搜索树 可以是红黑树或者AVL树
    >
    > list的迭代器是双向迭代器，支持++和--操作，并且随机访问的时间复杂度是O(n)的

23. vector和list排序使用的算法分别是什么

    > vector的排序主要是快排或者归并排序
    >
    > list的排序是用归并排序

24. emplace_back和pusb_back的区别

    > push_back是将已经构建好的对象插入到vector的末尾
    >
    > emplace_back是接收构建对象参数 然后用这些参数来构造对象再插入到末尾，避免了拷贝的开销

25. 如果经常进行头删和尾插 使用哪个数据结构比较好 vector的back和end的区别是什么

    > 使用deque双端队列或者list都挺好的
    >
    > back是获取最后一个元素的引用
    >
    > end是获取最后一个元素的迭代器

26. 红黑树 AVL树 B+树的关系是什么

    > 这三者都是二叉搜索树 用于数据的存储和管理 查询的效率比较高是log(n)
    >
    > 红黑树的特点是 节点是红色或者黑色 根节点是黑色 红节点不相邻 每一条路径都包含了相同的黑色节点 每次插入后可能需要旋转和重新上色
    >
    > AVL树是一种高度平衡的二叉搜索树 任何节点的左子树和右子树的高度差不超过1 这也导致AVL树需要频繁的调整平衡
    >
    > B+树不太了解

27. set插入的时候怎么保持红黑树的平衡的

    > 默认插入时是红色节点 
    >
    > * 如果父节点是黑色就不用调
    > *  如果父节点是红色就要看叔叔节点
    >   * 如果叔叔节点是红色
    >     * 就把父节点和叔叔节点都变为黑色 把祖父节点设为红色 然后继续向上调整
    >   * 如果叔叔节点是黑色或者不存在
    >     * 如果新节点是右孩子 父节点是左孩子就进行左旋转
    >     * 如果新节点是左孩子 则右旋转
    >     * 然后把父节点设为黑色 祖父节点设为红色 然后继续向上调整

28. 讲一讲哈希map 常见的hash的实现形式

    > 哈希表可以用数组或者哈希桶 也就是链地址法来实现
    >
    > 如果有哈希冲突在数组中可以用线性探测或者二次探测来找位置
    >
    > 当数据量超过某一个阈值时可能需要动态扩容

29. 讲一讲二分查找 有哪些方式能让数组有序

    > 二分查找的主要特点就是在一个有序序列中查找到目标值 每一次进行比较时 可以排除一半的错误答案 最终找到目标值
    >
    > 排序方法有冒泡排序 选择排序 插入排序 归并排序 快速排序 堆排序  

30. 讲一讲堆排序的时间复杂度分析

    > 堆排序主要是借助堆的数据结构来进行排序 分为大根堆和小根堆 也就是父节点的值大于等于每个子节点或者小于等于每个子节点
    >
    > 堆排序的主要过程其实就是进行插入的过程 将新元素插入到堆的末尾 然后进行向上调整 直到新元素不大于他的父节点为止
    >
    > 取出元素时 需要将堆顶元素与末尾元素交换 然后进行向下调整

31. 快速排序和堆排序 实现原理 最好和最坏的时间复杂度 最坏的情况是什么样的 要怎么优化不让最坏的情况出现

    > 快速排序的实现原理是选择一个基准元素 然后将剩余元素分为两类 一类是是小于的 一类是大于的 然后对这两类元素递归执行快速排序
    >
    > 当每次选择的基准元素都几乎均匀为非两部分时 递归深度是logn 每层比较的次数是n 时间复杂度就是o nlogn
    >
    > 最快情况下 每次选择的基准元素是最大或者最小的时候 递归深度就是n 每层比较次数是n 时间复杂度就是 $n^2$
    >
    > 优化方法：1. 随机选择 2. 取三个元素中间的 3. 小数组尽量避免使用快排 

32. 归并排序的实现原理

    > 他的思想就是将整个数组分为两个子数组 然后递归的对这两个子数组进行排序 最后进行合并 时间复杂度是nlogn

33. 怎么从一亿数据中怎么找出第5小的数

    > 维护一个小的堆 并行 分治

34. 线程和进程的区别 线程有哪些私有空间 为什么进程是资源分配的基本单位 线程是CPU调度的基本单位

    > 进程是资源分配的基本单位 每个进程都拥有自己的地址空间 数据 堆栈
    >
    > 线程是进程中的执行单元 是CPU调度的基本单位 他共享进程的资源 但有自己的栈和寄存器 还有自己的局部存储变量 在多线程环境下变量可以具有独立性
    >
    > 进程是用来确保各个进程的隔离和安全 对资源的分配管理 调度 都是以进程为单位的
    >
    > 线程的切换开销比较小 并且能够高效的利用CPU资源 允许线程在同一个进程内并发执行 提高运行效率

35. 多进程和多线程的区别 为什么多进程和多线程的通信效率会不同

    > 多进程是在操作系统中运行多个进程 每个进程的空间和资源是相互独立的 多线程是在同一个进程中的 是可以共享进程的空间和资源的
    >
    > 进程的创建和销毁开销比较大 因为需要独立分配和管理资源
    >
    > 进程的稳定性也没有线程好 线程之间有可能互相影响
    >
    > 进程间通信的主要是通过内存共享 管道 共享数据结构等方式进行通信 而多线程本身就是共享资源的 因此多线程的通信效率会高一点

36. 单线程情况下CPU占用率很高是因为什么？多线程呢？

    > 单线程：
    >
    > 	1. 计算密集型的任务 线程几乎一直在计算
    > 	1. 忙等 不断检查条件 不进行有效工作
    > 	1. IO密集型 未能有效的处理阻塞
    > 	1. 死循环
    >
    > 多线程：
    >
    > 1. 线程数量过多导致的频繁切换线程
    > 2. 资源争用 忙等
    > 3. 死锁

37. 怎么解决线程安全问题 同步与互斥的概念？

    > 解决线程安全问题主要是通过锁和条件变量
    >
    > 这两种方法主要是解决互斥和同步问题
    >
    > 互斥主要是为了保证同一时间只有一个线程能够访问特定的共享资源
    >
    > 同步主要是为了控制多个线程对共享资源的访问 来达到线程按照特定顺序特定条件执行的目的 同步可以通过互斥锁 条件变量 信号量来实现

38. 如何保证A线程运行至满足条件x时B线程运行？

    > 可以使用条件变量来控制 开始时条件变量设置为不满足 B线程会阻塞等待 当A线程执行完成后上锁设置为满足 然后通知等待的线程即可

39. 进程间的通信方式有哪些 这些方式有什么优缺点 应用场景是什么

    > * 匿名管道 优点是简单易用 适合一对一通信 效率比较高 缺点是只适用于父子进程 数据是字节流 对复杂的数据结构处理比较困难
    > * 命名管道 可以用于无缘的进程 通信方式比较灵活 创建和管理比较复杂 传输的数据是字节流 可以用于跨进程之际的通信 例如服务器和客户端的通信
    > * 消息队列 支持多个进程的通信 消息可以持久化 消息队列的创建和管理开销比较大 消息的大小收到限制 用于异步通信 对于消息顺序和优先级有要求的场景
    > * 共享内存 比较高效 不需要进行数据传输和复制 需要额外使用信号量来保证数据的一致性
    > * 信号 简单快速 用来通知特定时间的发生 一般只传递信号编号 不传递其他复杂信息
    > * 套接字 支持网络通信 可以双向通信 复杂度比较高 开销比较大 适用于网络模型
    > * 数据库 提供持久化存储 适用于大量数据的存储和搜索

40. 进程间通信对线程会有影响吗

    > 会影响一部分数据的一致性

41. 线程池的工作原理，流程，改进，如果空闲线程太多了怎么办，如果任务太多堆积了怎么办，这两种情况会影响到主线程么

    > 线程池就是在预处理时就开辟维护一组线程用于执行特定任务，然后开一个任务池或者任务队列来存储任务，当线程空闲时就从中取出任务进行执行
    >
    > 流程：初始化一定数量的工作线程 放入线程池 提供一个任务提交接口 用户可以将任务push到任务池中 检测到任务池不为空时 空闲线程从中取出任务并执行
    >
    > 改进：根据任务的数量和执行时间 动态增加或者减少工作线程的数量 负载均衡 空闲线程时间过长会自动销毁
    >
    > 空闲线程过多时需要设计一个回收策略 并且保持一个最小的线程数
    >
    > 任务堆积太多需要设置任务队列容量 必要时可以选择抛异常拒绝任务等策略 如果任务数量激增可以选择临时增加工作线程

42. 负载均衡有哪些策略

    > 轮询 加权轮询 最少连接数 随机分配 检测性能指标

43. Linux中常用的命令有哪些 详细介绍一些

    > 文件或者目录的管理 ls cd pwd rmdir rm cp mv
    >
    > 文件相关的 cat more less head tail vim
    >
    > 系统管理的 top ps kill df
    >
    > 网络相关的 ping netstat
    >
    > 权限管理 chmod chown 

44. 查看机器的CPU内存使用，可以怎么看？

    > top 
    >
    > ps 好像也可以看

45. Linux操作系统调度问题

    > 主要是时间片轮转还有优先级高的抢占优先级低的进程

46. 怎么理解堆和栈

    > 堆和栈都是进程地址空间的两个区域 
    >
    > 堆是用来动态分配内存的一块区域 在运行时可以动态创建对象和数据结构 需要手动管理 大小可变 访问速度比较满 长期使用可能会导致速率变慢
    >
    > 栈是用来存储局部变量和函数调用信息的内存区域 是遵循先进后出的特点的 分配和释放是自动的 大小是固定的 访问速度比较快 不太容易产生碎片

47. 讲一下进程地址空间

    > 进程地址空间是每个进程都会分配的一块虚拟内存区域 相当于操作系统许诺给进程可以使用的区域 操作系统将虚拟内存映射到物理内存
    >
    > 进程地址空间主要分为
    >
    > * 代码段 存可执行代码 只读 编译时就会确定下来
    > * 数据段 存储全局变量和静态变量
    > * 堆
    > * 栈

48. 调用函数时候栈空间的变化

    > 调用函数时 会创建栈帧 用来存储该函数的局部变量 参数 还有返回地址等信息 执行完成后会处理返回值 清理栈帧 然后跳转到之前的返回地址

49. 栈内存的最小单位是什么

    > 栈的最小单位通常是一个字 32位系统是32位4字节 64位系统是64位8字节

50. TCP和UDP的区别 包括socket编程方面 还有应用场景

    > TCP是面向连接 字节流的 是可靠的传输层协议 包括数据完整性 顺序 流量控制 差错检测方面的内容 建立连接时三次握手 释放连接时四次回收 主要用于可靠的信息传递
    >
    > UDP是面向无连接 数据报的 是不可靠的传输层协议 主要应用于高实时性的 允许出错的情况
    >
    > socket方面 
    >
    > 连接时 TCP使用socket创建套接字 bind绑定地址 listen监听连接请求 accept接收连接 UDP创建套接字 bind绑定地址
    >
    > 数据发送和接收 TCP使用send或者write 接收数据使用recv或者read 需要保证连接是打开的 对数据顺序是有保证的 UDP使用sendto recvfrom 不需要建立连接 可以随时发送

51. TCP连接建立和释放的过程

    > 建立：三次握手
    >
    > 1. 客户端发送SYN包给服务器 包含初始序列化
    > 2. 服务器收到后回复一个SYN-ACK包给客户端 表示统一建立连接
    > 3. 服务器收到之后 回复一个ACK确认服务器的序列号 此时可以携带数据进行通信
    >
    > 释放：四次回收
    >
    > 1. 主动关闭连接一方发送FIN包 表示数据发送完毕
    > 2. 服务端收到FIN包后 返回一个ACK确认包 此时服务器还有可能发送未发送完成的数据
    > 3. 服务端完成数据发送后 发送FIN包传递给客户端 表示可以关闭连接
    > 4. 客户端收到FIN包后 发送ACK给服务器 确认收到FIN 连接关闭

52. TCP的四次挥手，一定是四次挥手吗？

    > 如果服务端没有数据发送时可以将FIN和ACK包合并未一个数据包 可以减少为三次挥手

53. 怎么判断是四次挥手还是三次挥手？

    > 可以通过监控数据报 查看连接关闭时传输的数据包内容

54. TCP获取数据时怎么区分消息的边界 也就是怎么优化粘包问题

    > 可以通过消息长度+消息内容区分
    >
    > 或者规定特定结束符表示结束 HTTP是回车换行结束

55. TCP中time_wait的作用

    > 确认最后的ACK包被接收 允许重复的数据报丢失 避免端口重复使用

56. 原生socket要怎么用 select poll epoll的区别和使用场景

    > 原生socket的本质是文件描述符 可以通过select poll epoll来对文件描述符进行管理 也就是IO多路复用机制
    >
    > select是最早的机制 可以同时监视多个文件描述符 等待其编程可读可写或者异常 有点是简单 广泛支持 缺点是文件描述符数量有限制 每次调用时需要重新设置文件描述符集合 高并发时性能比较差
    >
    > poll类似于select 解决了数量上限的问题 但是也还是需要传递整个数组
    >
    > epoll是linux特有的 对于高并发连接释放好用 能够处理数万的文件描述符 支持水平触发和边缘触发

57. mysql有什么引擎，它们有什么区别？

58. 事务的ACID介绍一下

59. makefile或cmake知道吗？

60. linux下如何调试代码？

61. rpc是什么

62. docker是什么

63. 找出一个有序数组中出现次数超过数组大小一半的数，保证存在这个数，时间复杂度严格小于O(n)

64. 给你一个链表，结点个数为偶数，将链表中的每两个结点交换顺序，比如1->2->3->4->5->6 交换以后变为2->1->4->3->6->5

65. 一个圆形池塘 随机向其中扔三只鸭子 问这三个鸭子能被一个半圆包裹的概率是多少 n只鸭子的时候呢

66. 对我们公司（自动驾驶，无人驾驶）你有哪些了解

反问：

1. 如何培养实习生？有机会参与项目吗？我的实习部门是什么？做什么项目？需要转语言吗？