---
title: 每日算法打卡：翻硬币
date: 2024-01-04 11:56:04
tags: [算法,递推]
categories: [算法]
---

## 原题链接

[1208. 翻硬币](https://www.acwing.com/problem/content/1210/)

题目难度：简单

题目来源：第四届蓝桥杯省赛C++B组

## 题目描述

小明正在玩一个“翻硬币”的游戏。

桌上放着排成一排的若干硬币。我们用 \* 表示正面，用 o 表示反面（是小写字母，不是零）。

比如，可能情形是：`**oo***oooo`

如果同时翻转左边的两个硬币，则变为：`oooo***oooo`

现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？

我们约定：把翻动相邻的两个硬币叫做一步操作。

#### 输入格式

两行等长的字符串，分别表示初始状态和要达到的目标状态。

#### 输出格式

一个整数，表示最小操作步数

#### 数据范围

输入字符串的长度均不超过100。  
数据保证答案一定有解。

#### 输入样例1：

```
**********
o****o**** 
```

#### 输出样例1：

```
5 
```

#### 输入样例2：

```
*o**o***o***
*o***o**o*** 
```

#### 输出样例2：

```
1 
```

## 题目分析

这个题就类似于之前的费解的开关的题目，每次翻硬币会同时带动两个硬币，问最少需要多少次到达目标状态

这一类问题其实是有一个固定形式的，是给定初态和末态，然后规定一些操作，问最少需要多少次操作可以从初态到达末态，这种问题一般有两种基本做法，一种就是宽搜(bfs)，另一种就是递推做法

因此我们只需要从头到尾，依次保证前面的硬币符合条件即可，每一次使该位置和位置之后的硬币反转即可，而且题目保证了必有解

## 示例代码

```cpp
#include<iostream>
#include<string>
using namespace std;
string src, dest; // src表示初态，dest表示末态
int ans = 0; // 步数
void turn(int cur) // 翻硬币
{
    if (src[cur] == '*')
        src[cur] = 'o';
    else if (src[cur] == 'o')
        src[cur] = '*';
    if (src[cur + 1] == '*')
        src[cur + 1] = 'o';
    else if (src[cur + 1] == 'o')
        src[cur + 1] = '*';
    ans++;
}
int main()
{
    cin >> src >> dest;
    for (int i = 0; i < src.size() - 1; i++) // 当对应位置状态不同时翻转
    {
        if (src[i] != dest[i])
            turn(i);
    }
    cout << ans;
    return 0;
}
```

