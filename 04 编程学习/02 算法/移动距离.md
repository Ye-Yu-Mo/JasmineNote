---
title: 每日算法打卡：移动距离
date: 2024-01-23 16:48:35
tags: [算法,模拟]
categories: [算法]
---

## 原题链接

[1219. 移动距离](https://www.acwing.com/problem/content/1221/)

题目难度：简单

题目来源：第六届蓝桥杯省赛C++ B组,第六届蓝桥杯省赛Java A/C组

## 题目描述

X星球居民小区的楼房全是一样的，并且按矩阵样式排列。

其楼房的编号为 1,2,3…

当排满一行时，从下一行相邻的楼往反方向排号。

比如：当小区排号宽度为 6 时，开始情形如下：

```
1  2  3  4  5  6
12 11 10 9  8  7
13 14 15 ..... 
```

我们的问题是：已知了两个楼号 m 和 n，需要求出它们之间的最短移动距离（不能斜线方向移动）。

#### 输入格式

输入共一行，包含三个整数 w,m,n，w 为排号宽度，m,n 为待计算的楼号。

#### 输出格式

输出一个整数，表示 m, n 两楼间最短移动距离。

#### 数据范围

1≤w,m,n≤10000

#### 输入样例：

```
6 8 2 
```

#### 输出样例：

```
4 
```

## 题目分析

这道题目的意思非常简单，重在如何进行模拟，或者通过找规律也能做出来

这道题目要求的距离实际上在数学中叫做曼哈顿距离，给定两个点的坐标可以用公式表示为$|x_1-x_2|+|y_1-y_2|$

那么其实问题就变成了如何求这两个编号的坐标了，在这里有一个操作，将所有的编号都减一，这样的话第一行刚好和列号相同

对于行号我们可以观察到，行号就是编号除宽度

如果是正常的数组，列号可以使用行号模宽度即可，在这道题里就只需反转一下即可

## 示例代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

int main()
{
    int w, m, n;
    cin >> w >> m >> n;
    m--, n--;
    int x1 = m / w, x2 = n / w;
    int y1 = m % w, y2 = n % w;
    if (x1 % 2 == 1)
        y1 = w - 1 - y1;
    if (x2 % 2 == 1)
        y2 = w - 1 - y2;
    cout << abs(x2 - x1) + abs(y2 - y1) << '\n';
    return 0;
}
```



