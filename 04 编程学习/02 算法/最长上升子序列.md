---
title: 每日算法打卡：最长上升子序列
date: 2024-01-14 16:26:00
tags: [算法,DP,最长上升子序列]
categories: [算法]
---

## 原题链接

[895. 最长上升子序列](https://www.acwing.com/problem/content/897/)

题目难度：简单

## 题目描述

给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。

#### 输入格式

第一行包含整数 N。

第二行包含 N 个整数，表示完整序列。

#### 输出格式

输出一个整数，表示最大长度。

#### 数据范围

$1 \le N \le 1000$，  
$-10^9 \le 数列中的数 \le 10^9$

#### 输入样例：

```
7
3 1 2 1 8 5 6 
```

#### 输出样例：

```
4 
```

## 题目分析

这道题目的意思很简单，就是从序列中找到一个最长的严格递增的子序列，例如样例中的结果就是，1,2,5,6

这是一个经典的DP问题，我们依旧从集合的角度来看，集合的含义就是所有以a[i]结尾的严格单调上升的子序列

从状态计算的角度来看，我们以倒数第二个位置可以取的不同的数字进行集合划分，一共有i种情况，分别是空，a[1]，a[2]一直到a[i-1]，那么对于其中任意一种情况，都可以继续进行划分，当不符合条件的时候，只需要进行排除即可

## 示例代码

```cpp
#include<iostream>
using namespace std;

const int N = 1010;
int n;
int a[N],f[N];

int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    
    for(int i=1;i<=n;i++)
    {
        f[i]=1; // 如果是空集的话，至少是1
        for(int j=1;j<i;j++)
        {
            if(a[j]<a[i])
                f[i] = max(f[i],f[j]+1);
        }
    }
    int ans = 0;
    for(int i=1;i<=n;i++)
        if(f[i]>ans)
            ans = f[i];
    cout<<ans<<'\n';
    return 0;
}
```



